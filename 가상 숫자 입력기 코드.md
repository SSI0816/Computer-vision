가상 숫자 인식기

코드
```
include<iostream>
#include<opencv2/opencv.hpp> // 헤더파일 포함
#include<cmath>
using namespace std; // 객체명 앞에 std:: 생략
using namespace cv; // 객체명 앞에 cv:: 생략
using namespace cv::dnn; // 객체명 앞에 cv::dnn 생략
using namespace cv::ml; // 객체명 앞에 cv::ml 생략

int main()
{

	VideoCapture cap(0);
	if (!cap.isOpened()) { cerr << "Camera open failed!" << endl; return -1; }

	Mat input, handimg, mask, element;
	vector<Rect>faces;
	vector<vector<Point>> contours;
	double max_con_index = 0;
	double max = 0;
	vector<Point>hull;
	vector<Point> save;
	vector<Point>  his;
	int filenumber = 0;
	
	while (1)
	{
		cap >> input;
		if (input.empty()) { break; }
		cvtColor(input, handimg, COLOR_BGR2YCrCb);
		inRange(handimg, Scalar(0, 135, 80), Scalar(255, 170, 130), handimg);
		
		element = getStructuringElement(1, Size(7, 7));
		(handimg, handimg, element);
		dilate(handimg, handimg, element);
		flip(input, input, 1);
		flip(handimg, handimg, 1);

		mask = handimg.clone();
		findContours(mask, contours, RETR_LIST, CHAIN_APPROX_SIMPLE);
		for (int i = 0; i < contours.size(); i++)
		{
			if (contourArea(contours[i]) > contourArea(contours[max_con_index])) {
				max_con_index = i;
				max = contourArea(contours[i]);
			}
		}
	
		approxPolyDP(contours[max_con_index], contours[max_con_index], 
				arcLength(contours[max_con_index], true) * 0.03, false);
		convexHull(contours[max_con_index], hull);
		for (int j = 0; j < hull.size() - 1; j++)
		{
			line(input, hull[j], hull[j + 1], Scalar(255, 255, 0), 3);
		}
		circle(input, hull[0], 3, Scalar(255, 0, 0), 10);
	
		double dis0_1 = sqrt(pow(hull[0].x - hull[1].x, 2) + pow(hull[0].y - hull[1].y, 2));
		double dis1_2 = sqrt(pow(hull[1].x - hull[2].x, 2) + pow(hull[1].y - hull[2].y, 2));
		double angle0_1 = atan2(hull[1].y - hull[0].y, hull[1].x - hull[0].x);
		double angle1_2 = atan2(hull[2].y - hull[1].y, hull[2].x - hull[1].x);
		double add_dis0_1 = 0, add_dis1_2 = 0;
		double add_angle0_1 = 0, add_angle1_2 = 0;
		for (int i = 0; i < 10000; i++)
		{
			add_dis0_1 += dis0_1;
			add_dis1_2 += dis1_2;
			add_angle0_1 += angle0_1;
			add_angle1_2 += angle1_2;
		}
		double avr_dis0_1 = add_dis0_1 / 10000, avr_dis1_2 = add_dis1_2 / 10000;
		double avr_angle0_1 = add_angle0_1 / 10000, avr_angle1_2 = add_angle1_2 / 10000;
	
		if ((avr_dis0_1 > 20 && avr_dis0_1 < 50) && (avr_dis1_2 > 65 && avr_dis1_2 < 85) 
			&& (avr_angle0_1 > 0.3 && avr_angle0_1< 0.55) && (avr_angle1_2 > 0.7 && avr_angle1_2 < 0.9))
		{	
			his.clear();
			save.clear();

		}
		if ((avr_dis0_1 >= 120 && avr_dis0_1 <= 175) && (avr_dis1_2 >= 50 && avr_dis1_2 <= 140) 
			&& (avr_angle0_1 > 0.9 && avr_angle0_1 < 1.1) && (avr_angle1_2 > 1.9))
		{
			int i = 0;
			if (i == 0)
			{
				his.push_back(hull[0]);
			}
			save.push_back(hull[0]);
			for (int d = 0; d < his.size() - 1; d++) 
			{
				line(input, Point(save[d].x, save[d].y), Point(his[d].x, his[d].y), Scalar(255, 255, 255), 20);
			}
			i++;
		}
		if ((avr_dis0_1 > 85 && avr_dis0_1 <= 100)  && (avr_angle0_1 > 0.2 && avr_angle0_1 < 0.55) && (avr_angle1_2 > 1.5))
		{
			if (his.size() <= 1) imshow("input", input);
			else
			{
				for (int d = 0; d < his.size() - 1; d++) 
				{
					line(input, Point(save[d].x, save[d].y), Point(his[d].x, his[d].y), Scalar(255, 255, 255), 20);
				}
				
				imwrite("hand_number.jpg", input);
				break;
			}
		}
		else
		{
			if (his.size() <= 1) imshow("input", input);
			else for (int d = 0; d < his.size() - 1; d++)
			{
				line(input, Point(save[d].x, save[d].y), Point(his[d].x, his[d].y), Scalar(255, 255, 255), 20);
			}
		}
		max_con_index = 0;
		imshow("input", input);
		imshow("hand", handimg);
		if (waitKey(1) == 27) break;
	}

	vector<int> classNames = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // 정수형 클레스 백터
	Net net = readNet("hand_number_model.pb"); // 학습모델, 구성파일을 불러옴
	if (net.empty()) { cerr << "Network load failed!" << endl; return -1; } // 애러 처리

	double maxVal; // 실수를 선언할 변수
	Point maxLoc; // Point를 선언할 변수

	Mat hand_result = imread("hand_number.jpg");
	inRange(hand_result, Scalar(250, 250, 250), Scalar(255, 255, 255), hand_result);
	element = getStructuringElement(1, Size(3, 3));
	erode(hand_result, hand_result, element);
	dilate(hand_result, hand_result, element);
	cvtColor(hand_result, hand_result, COLOR_GRAY2BGR);
	imshow("result", hand_result);
	waitKey();

	Mat inputBlob = blobFromImage(hand_result, 1, Size(224, 224)); // 입력 영상을 blob 행렬로 변환
	net.setInput(inputBlob); // 네트워크 테스트 입력 설정
	Mat prob = net.forward(); // 예측(추론) 실행
	minMaxLoc(prob, NULL, &maxVal, NULL, &maxLoc); // 최대값과 그 저장위치 찾는 함수
	cout << classNames[maxLoc.x] << endl;
	return 0;
}
```
